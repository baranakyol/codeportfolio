---
title: "ba2500 Arima Garch Model Fit on S&P 500"
author: "Baran Akyol"
date: "November 7, 2016"
output:
  html_document: default
  pdf_document: default
---


```{r, eval=FALSE, include=FALSE}

library("xts") #for time series
library("nloptr") #for optimization
library(zoo)
library("dygraphs") #for plots
library("magrittr") # pipes
library(dplyr)
#library(streamgraph)
#library(viridis)

library(quantmod)
library(lattice)
library(timeSeries)
library(rugarch)

```

```{r, eval=FALSE}
getSymbols("^GSPC", from="2004-01-01")

spReturns = diff(log(Cl(GSPC)))
spReturns[as.character(head(index(Cl(GSPC)),1))] = 0
windowLength <- 500
foreLength <- length(spReturns) - windowLength
forecasts <- matrix(NA,foreLength+1,2)
```


```{r, eval=FALSE}

if (1==1)
{
  for (d in 0:foreLength) {
    #2. Obtain the S&P500 rolling window for this day
      spReturnsOffset = spReturns[(1+d):(windowLength+d)]
  
      #3. Fit the ARIMA model
      final.aic <- Inf
      final.order <- c(0,0,0)
      for (p in 0:5) for (q in 0:5) {
      #for (p in 1) for (q in 0) {
          if ( p == 0 && q == 0) {
              next
          }
  
          arimaFit = tryCatch( arima(spReturnsOffset, order=c(p, 0, q)),
                               error=function( err ) FALSE,
                               warning=function( err ) FALSE )
          #4. if we got the fit return update the AIC else move to the next model.
          if( !is.logical( arimaFit ) ) {
              current.aic <- AIC(arimaFit)
              if (current.aic < final.aic) {
                  final.aic <- current.aic
                  final.order <- c(p, 0, q)
                  final.arima <- arima(spReturnsOffset, order=final.order)
              }
          } else {
              next
          }
      }
  
      #7. Specify the ARMA(p,q)-GARCH(1,1) model with Student-t innovations  to fit
      spec = ugarchspec(
          variance.model=list(garchOrder=c(1,1)),
          mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
          distribution.model="std"
      )
      #8. Fit the ARMA(p,q)-GARCH(1,1) model
      fit = tryCatch(
        ugarchfit(
          spec, spReturnsOffset, solver = 'hybrid'
        ), error=function(e) e, warning=function(w) w
      )
  
      #9. If the GARCH model does not converge, set the direction to "long" else
      # choose the correct forecast direction based on the returns prediction
      # Output the results to the screen and the forecasts vector
      if(is(fit, "warning") || is(fit,"error") ) {
        forecasts[d+1,1] = index(spReturnsOffset)[windowLength]
        forecasts[d+1,2] = 1
        print("warning or error")
        print(paste(paste('Date: ',index(spReturnsOffset)[windowLength],sep=''), paste(' Signal = ',1,sep=''),paste(' Progress = ',paste(round(10000*d/foreLength)/100,'%',sep=''),sep=''), sep=";")) 
      } else {
        #10 compute the one-step-ahead forecast and store the trading decision {-1,1}
        fore = ugarchforecast(fit, n.ahead=1)
        ind = fore@forecast$seriesFor
        forecasts[d+1,1] = index(spReturnsOffset)[windowLength]
        forecasts[d+1,2] = ifelse(ind[1] < 0, -1, 1)
        #print the date 
        print(paste(paste('Date: ',index(spReturnsOffset)[windowLength],sep=''), paste(' Signal = ',ifelse(ind[1] < 0, -1, 1),sep=''),paste(' Progress = ',paste(round(10000*d/foreLength)/100,'%',sep=''),sep=''), sep=";")) 
      }
}

write.csv(forecasts, file="forecasts.csv", row.names=FALSE,quote=FALSE)

}
``` 

